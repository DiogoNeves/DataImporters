# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_sources_core.ipynb (unless otherwise specified).

__all__ = ['AUDIO_EXTENSIONS', 'Source', 'normalise_label', 'normalise_all_labels', 'get_footstep_type',
           'get_filenames', 'remove_all_extensions', 'get_hash', 'process']

# Cell

import pandas as pd
import os
import xxhash
import shutil
import stringcase

# These are based on what I find in the data
AUDIO_EXTENSIONS = (".wav")

# Cell

class Source:
    """All sources should implement this class."""
    @property
    def name(self) -> str:
        raise NotImplementedError()

    def get_files(self, root_dir: str) -> list[tuple[str, str]]:
        """List of paths and files to process, as returned by `get_filenames`."""
        raise NotImplementedError()

    def get_category(self, path: str, filename: str) -> str:
        """Category name for the given file (most sources hardcode a single category)."""
        raise NotImplementedError()

    def get_labels(self, path: str, filename: str) -> list[str]:
        """List of labels for the given file."""
        raise NotImplementedError()

    def get_extra(self, path: str, filename: str) -> str:
        """(Optional) Extra information for the given file."""
        return None

# Cell

def normalise_label(label: str) -> str:
    """Normalise a label to be used in the metadata
    (`process` should call this automatically)."""
    return stringcase.capitalcase(stringcase.snakecase(label.lower().strip()))

def normalise_all_labels(labels: list[str]) -> list[str]:
    return [normalise_label(label) for label in labels]

# Cell

def get_footstep_type(filename: str) -> str:
    step_types = ("walk", "scuffs", "stomps", "squishes", "wade", "scrape")
    for step in step_types:
        if step in filename.lower():
            return step
    return None

# Cell

def get_filenames(root_dir: str) -> list[tuple[str, str]]:
    "List audio filenames in the directory."
    return ((root, filename) for root, _, files in os.walk(root_dir)
            for filename in files
            if filename.endswith(AUDIO_EXTENSIONS))

# Cell

def remove_all_extensions(files: list[tuple[str, str]]) -> list[tuple[str, str]]:
    return [(root, os.path.splitext(filename)[0]) for root, filename in files]

# Cell

def get_hash(file_path: str) -> str:
    "Get the xxhash64 hash of the file."
    with open(os.path.normpath(file_path), "rb") as f:
        return xxhash.xxh64(f.read()).hexdigest()

# Internal Cell

def _get_hashed_filename(path: str, filename: str) -> str:
    hash = get_hash(os.path.join(path, filename))
    extension = os.path.splitext(filename)[1]
    return hash + extension

def _prepare_target_dir(target_dir: str):
    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

def _sync_hashed_audio_files(files: tuple[str, str], hashes: list[str], target_dir: str):
    for [path, filename], hash in zip(files, hashes):
        original_file_path = os.path.join(path, filename)
        target_file_path = os.path.join(target_dir, hash)
        if not os.path.exists(target_file_path):
            shutil.copy2(original_file_path, target_file_path)

# Cell

def process(source: Source, data_dir: str, version: int) -> pd.DataFrame:
    """Process source and return the metadata."""
    assert source.name is not None and source.name.strip() != ""

    source_dir = os.path.join(data_dir, "original", source.name)
    files = source.get_files(source_dir)
    if len(files) == 0:
        raise ValueError("No files found in source")

    metadata = pd.DataFrame()
    clean_files = remove_all_extensions(files)
    metadata["filename"] = hashed_filenames = [_get_hashed_filename(path, filename)
                                               for path, filename in files]
    metadata["category"] = [source.get_category(path, filename) for path, filename in clean_files]
    metadata["label"] = [",".join(normalise_all_labels(source.get_labels(path, filename)))
                         for path, filename in clean_files]
    metadata["extra"] = [source.get_extra(path, filename) for path, filename in clean_files]
    metadata["source"] = [source.name] * len(files)
    metadata["version"] = [version] * len(files)

    target_dir = os.path.join(data_dir, "intermediate", source.name)
    _prepare_target_dir(target_dir)

    metadata.to_csv(os.path.join(target_dir, "metadata.csv"), index=False)
    _sync_hashed_audio_files(files, hashed_filenames, target_dir)

    return metadata